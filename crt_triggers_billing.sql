--*****************************************************
--	Billing Triggers
--*****************************************************
--/**---------------------------------------------------------------------------------------
--/* Script			: crt_trig_billing.sql
--/* Author			: Sridevi Tadisetti  
--/* Product		: Infor SCE Suite 
--/* Component		: Billing - Version 12.7
--/* Date			: 18/06/2025        
--/* Description	: Script to create Triggers for Billing
--/* RDBMS			: Postgresql
--/* Schema			: Billing
--/* Modification History:
--/*----------------------------------------------------------------------------------------
--/* Modified by	Date			Description    
--/*----------------------------------------------------------------------------------------
--/* 
--/*
--/*-----------------------------------------------------------------------------------------

-- The query should be run at Postgresql with Postgres user


CREATE OR REPLACE FUNCTION BILLADMIN.BIC_ACTIVITY_FIELD_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_FIELD_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_ACTIVITY_FIELD;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_FIELD_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_ACTIVITY_FIELD_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_FIELD_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_ACTIVITY_FIELD_TRG
 before INSERT
  ON BILLADMIN.BIC_ACTIVITY_FIELD
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_ACTIVITY_FIELD_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_ACTIVITY_FILTER_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.FILTER_ID := old.FILTER_ID; 
	ELSIF TG_OP = 'INSERT' AND new.FILTER_ID IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_ACTFILTER_FILTER_ID_SEQ') INTO new.FILTER_ID ;
		IF new.FILTER_ID = 1 THEN 
			SELECT COALESCE(max(FILTER_ID),0) INTO v_newVal FROM billadmin.BIC_ACTIVITY_FILTER;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_ACTFILTER_FILTER_ID_SEQ') INTO v_incval ;
				END LOOP;
				new.FILTER_ID := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_ACTFILTER_FILTER_ID_SEQ';
		IF num1 <= new.FILTER_ID THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_ACTFILTER_FILTER_ID_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.FILTER_ID;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_ACTIVITY_FILTER_TRG
 before INSERT
  ON BILLADMIN.BIC_ACTIVITY_FILTER
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_ACTIVITY_FILTER_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_ACTIVITY_TRANS_ID_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ID := old.ID; 
	ELSIF TG_OP = 'INSERT' AND new.ID IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_TRANS_ID_SEQ') INTO new.ID ;
		IF new.ID = 1 THEN 
			SELECT COALESCE(max(ID),0) INTO v_newVal FROM billadmin.BIC_ACTIVITY_TRANS;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_TRANS_ID_SEQ') INTO v_incval ;
				END LOOP;
				new.ID := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_ACTIVITY_TRANS_ID_SEQ';
		IF num1 <= new.ID THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_TRANS_ID_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ID;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_ACTIVITY_TRANS_ID_TRG
 before INSERT
  ON BILLADMIN.BIC_ACTIVITY_TRANS
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_ACTIVITY_TRANS_ID_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_ACTIVITY_TYPE_ACTIVITY_T_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ACTIVITY_TYPE_KEY := old.ACTIVITY_TYPE_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ACTIVITY_TYPE_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_TYPE_ACTIVITY_TYP') INTO new.ACTIVITY_TYPE_KEY ;
		IF new.ACTIVITY_TYPE_KEY = 1 THEN 
			SELECT COALESCE(max(ACTIVITY_TYPE_KEY),0) INTO v_newVal FROM billadmin.BIC_ACTIVITY_TYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_TYPE_ACTIVITY_TYP') INTO v_incval ;
				END LOOP;
				new.ACTIVITY_TYPE_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_ACTIVITY_TYPE_ACTIVITY_TYP';
		IF num1 <= new.ACTIVITY_TYPE_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_ACTIVITY_TYPE_ACTIVITY_TYP') INTO num1 ;
				EXIT WHEN num1 >= new.ACTIVITY_TYPE_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_ACTIVITY_TYPE_ACTIVITY_T_1
 before INSERT
  ON BILLADMIN.BIC_ACTIVITY_TYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_ACTIVITY_TYPE_ACTIVITY_T_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_ACTTYPE_FIELD_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_ACTTYPE_FIELD_ACTIVITY_TYP') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_ACTTYPE_FIELD;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_ACTTYPE_FIELD_ACTIVITY_TYP') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_ACTTYPE_FIELD_ACTIVITY_TYP';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_ACTTYPE_FIELD_ACTIVITY_TYP') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_ACTTYPE_FIELD_TRG
 before INSERT
  ON BILLADMIN.BIC_ACTTYPE_FIELD
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_ACTTYPE_FIELD_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_BILL_GROUP_DET_BILL_GRPD_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.BILL_GRPDET_KEY := old.BILL_GRPDET_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.BILL_GRPDET_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_BILL_GROUP_DET_BILL_GRPDET') INTO new.BILL_GRPDET_KEY ;
		IF new.BILL_GRPDET_KEY = 1 THEN 
			SELECT COALESCE(max(BILL_GRPDET_KEY),0) INTO v_newVal FROM billadmin.BIC_BILL_GROUP_DET;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_BILL_GROUP_DET_BILL_GRPDET') INTO v_incval ;
				END LOOP;
				new.BILL_GRPDET_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_BILL_GROUP_DET_BILL_GRPDET';
		IF num1 <= new.BILL_GRPDET_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_BILL_GROUP_DET_BILL_GRPDET') INTO num1 ;
				EXIT WHEN num1 >= new.BILL_GRPDET_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_BILL_GROUP_DET_BILL_GRPD_1
 before INSERT
  ON BILLADMIN.BIC_BILL_GROUP_DET
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_BILL_GROUP_DET_BILL_GRPD_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CHARGE_ACCT_CHARGE_ACCT__1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.CHARGE_ACCT_KEY := old.CHARGE_ACCT_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.CHARGE_ACCT_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_ACCT_CHARGE_ACCT_KE') INTO new.CHARGE_ACCT_KEY ;
		IF new.CHARGE_ACCT_KEY = 1 THEN 
			SELECT COALESCE(max(CHARGE_ACCT_KEY),0) INTO v_newVal FROM billadmin.BIC_CHARGE_ACCT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_ACCT_CHARGE_ACCT_KE') INTO v_incval ;
				END LOOP;
				new.CHARGE_ACCT_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CHARGE_ACCT_CHARGE_ACCT_KE';
		IF num1 <= new.CHARGE_ACCT_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_ACCT_CHARGE_ACCT_KE') INTO num1 ;
				EXIT WHEN num1 >= new.CHARGE_ACCT_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CHARGE_ACCT_CHARGE_ACCT__1
 before INSERT
  ON BILLADMIN.BIC_CHARGE_ACCT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CHARGE_ACCT_CHARGE_ACCT__1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CHARGE_CHARGE_NO_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.CHARGE_NO := old.CHARGE_NO; 
	ELSIF TG_OP = 'INSERT' AND new.CHARGE_NO IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_CHARGE_NO_SEQ') INTO new.CHARGE_NO ;
		IF new.CHARGE_NO = 1 THEN 
			SELECT COALESCE(max(CHARGE_NO),0) INTO v_newVal FROM billadmin.BIC_CHARGE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_CHARGE_NO_SEQ') INTO v_incval ;
				END LOOP;
				new.CHARGE_NO := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CHARGE_CHARGE_NO_SEQ';
		IF num1 <= new.CHARGE_NO THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_CHARGE_NO_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.CHARGE_NO;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CHARGE_CHARGE_NO_TRG
 before INSERT
  ON BILLADMIN.BIC_CHARGE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CHARGE_CHARGE_NO_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CHARGE_DIST_CHARGE_DIST__1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.CHARGE_DIST_KEY := old.CHARGE_DIST_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.CHARGE_DIST_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_DIST_CHARGE_DIST_KE') INTO new.CHARGE_DIST_KEY ;
		IF new.CHARGE_DIST_KEY = 1 THEN 
			SELECT COALESCE(max(CHARGE_DIST_KEY),0) INTO v_newVal FROM billadmin.BIC_CHARGE_DIST;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_DIST_CHARGE_DIST_KE') INTO v_incval ;
				END LOOP;
				new.CHARGE_DIST_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CHARGE_DIST_CHARGE_DIST_KE';
		IF num1 <= new.CHARGE_DIST_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CHARGE_DIST_CHARGE_DIST_KE') INTO num1 ;
				EXIT WHEN num1 >= new.CHARGE_DIST_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CHARGE_DIST_CHARGE_DIST__1
 before INSERT
  ON BILLADMIN.BIC_CHARGE_DIST
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CHARGE_DIST_CHARGE_DIST__1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CHRG_ACCT_DET_CHARGE_DET_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.CHARGE_DET_KEY := old.CHARGE_DET_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.CHARGE_DET_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CHRG_ACCT_DET_CHARGE_DET_K') INTO new.CHARGE_DET_KEY ;
		IF new.CHARGE_DET_KEY = 1 THEN 
			SELECT COALESCE(max(CHARGE_DET_KEY),0) INTO v_newVal FROM billadmin.BIC_CHRG_ACCT_DET;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CHRG_ACCT_DET_CHARGE_DET_K') INTO v_incval ;
				END LOOP;
				new.CHARGE_DET_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CHRG_ACCT_DET_CHARGE_DET_K';
		IF num1 <= new.CHARGE_DET_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CHRG_ACCT_DET_CHARGE_DET_K') INTO num1 ;
				EXIT WHEN num1 >= new.CHARGE_DET_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CHRG_ACCT_DET_CHARGE_DET_1
 before INSERT
  ON BILLADMIN.BIC_CHRG_ACCT_DET
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CHRG_ACCT_DET_CHARGE_DET_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_ACTFIELD_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTFIELD_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_ACTFIELD;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTFIELD_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_ACTFIELD_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTFIELD_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_ACTFIELD_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_ACTFIELD
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_ACTFIELD_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_ACTFILTER_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTFILTER_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_ACTFILTER;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTFILTER_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_ACTFILTER_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTFILTER_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_ACTFILTER_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_ACTFILTER
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_ACTFILTER_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_ACTTYPE_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTTYPE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_ACTTYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTTYPE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_ACTTYPE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_ACTTYPE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_ACTTYPE_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_ACTTYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_ACTTYPE_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_BILLEVEL_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_BILLEVEL_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_BILLEVEL;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_BILLEVEL_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_BILLEVEL_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_BILLEVEL_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_BILLEVEL_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_BILLEVEL
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_BILLEVEL_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_CHGTYPE_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_CHGTYPE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_CHGTYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_CHGTYPE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_CHGTYPE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_CHGTYPE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_CHGTYPE_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_CHGTYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_CHGTYPE_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_CHGTYPNO_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_CHGTYPNO_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_CHGTYPNO;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_CHGTYPNO_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_CHGTYPNO_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_CHGTYPNO_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_CHGTYPNO_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_CHGTYPNO
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_CHGTYPNO_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_COSTALLOC_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTALLOC_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_COSTALLOC;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTALLOC_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_COSTALLOC_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTALLOC_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_COSTALLOC_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_COSTALLOC
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_COSTALLOC_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_COSTLVL_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTLVL_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_COSTLVL;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTLVL_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_COSTLVL_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTLVL_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_COSTLVL_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_COSTLVL
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_COSTLVL_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_COSTTYPE_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTTYPE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_COSTTYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTTYPE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_COSTTYPE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_COSTTYPE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_COSTTYPE_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_COSTTYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_COSTTYPE_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_DISPFMT_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_DISPFMT_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_DISPFMT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_DISPFMT_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_DISPFMT_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_DISPFMT_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_DISPFMT_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_DISPFMT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_DISPFMT_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_EVENTSPEC_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_EVENTSPEC_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_EVENTSPEC;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_EVENTSPEC_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_EVENTSPEC_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_EVENTSPEC_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_EVENTSPEC_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_EVENTSPEC
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_EVENTSPEC_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_EVENTTYPE_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_EVENTTYPE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_EVENTTYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_EVENTTYPE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_EVENTTYPE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_EVENTTYPE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_EVENTTYPE_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_EVENTTYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_EVENTTYPE_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_FILTFLD_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_FILTFLD_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_FILTFLD;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_FILTFLD_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_FILTFLD_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_FILTFLD_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_FILTFLD_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_FILTFLD
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_FILTFLD_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_INTERTYPE_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_INTERTYPE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_INTERTYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_INTERTYPE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_INTERTYPE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_INTERTYPE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_INTERTYPE_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_INTERTYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_INTERTYPE_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_INVSTATUS_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_INVSTATUS_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_INVSTATUS;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_INVSTATUS_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_INVSTATUS_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_INVSTATUS_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_INVSTATUS_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_INVSTATUS
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_INVSTATUS_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_INVTYPE_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_INVTYPE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_INVTYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_INVTYPE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_INVTYPE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_INVTYPE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_INVTYPE_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_INVTYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_INVTYPE_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_MATCH_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_MATCH_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_MATCH;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_MATCH_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_MATCH_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_MATCH_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_MATCH_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_MATCH
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_MATCH_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_MINLEVEL_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_MINLEVEL_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_MINLEVEL;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_MINLEVEL_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_MINLEVEL_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_MINLEVEL_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_MINLEVEL_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_MINLEVEL
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_MINLEVEL_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_PROFILE_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_PROFILE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_PROFILE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_PROFILE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_PROFILE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_PROFILE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_PROFILE_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_PROFILE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_PROFILE_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_REPORT_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_REPORT_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_REPORT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_REPORT_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_REPORT_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_REPORT_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_REPORT_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_REPORT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_REPORT_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_RPTCATG_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_RPTCATG_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_RPTCATG;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_RPTCATG_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_RPTCATG_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_RPTCATG_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_RPTCATG_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_RPTCATG
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_RPTCATG_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_SRCTYPE_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_SRCTYPE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_SRCTYPE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_SRCTYPE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_SRCTYPE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_SRCTYPE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_SRCTYPE_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_SRCTYPE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_SRCTYPE_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_SYSACT_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_SYSACT_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_SYSACT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_SYSACT_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_SYSACT_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_SYSACT_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_SYSACT_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_SYSACT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_SYSACT_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CODE_UOMLEVEL_ROW_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CODE_UOMLEVEL_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_CODE_UOMLEVEL;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CODE_UOMLEVEL_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CODE_UOMLEVEL_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CODE_UOMLEVEL_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CODE_UOMLEVEL_ROW_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CODE_UOMLEVEL
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CODE_UOMLEVEL_ROW_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CONTRACT_CONTRACT_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.CONTRACT_KEY := old.CONTRACT_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.CONTRACT_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CONTRACT_CONTRACT_KEY_SEQ') INTO new.CONTRACT_KEY ;
		IF new.CONTRACT_KEY = 1 THEN 
			SELECT COALESCE(max(CONTRACT_KEY),0) INTO v_newVal FROM billadmin.BIC_CONTRACT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CONTRACT_CONTRACT_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.CONTRACT_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CONTRACT_CONTRACT_KEY_SEQ';
		IF num1 <= new.CONTRACT_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CONTRACT_CONTRACT_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.CONTRACT_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CONTRACT_CONTRACT_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_CONTRACT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CONTRACT_CONTRACT_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_CONTRACT_DET_CONTRACT_DE_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.CONTRACT_DET_KEY := old.CONTRACT_DET_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.CONTRACT_DET_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_CONTRACT_DET_CONTRACT_DET_') INTO new.CONTRACT_DET_KEY ;
		IF new.CONTRACT_DET_KEY = 1 THEN 
			SELECT COALESCE(max(CONTRACT_DET_KEY),0) INTO v_newVal FROM billadmin.BIC_CONTRACT_DET;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_CONTRACT_DET_CONTRACT_DET_') INTO v_incval ;
				END LOOP;
				new.CONTRACT_DET_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_CONTRACT_DET_CONTRACT_DET_';
		IF num1 <= new.CONTRACT_DET_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_CONTRACT_DET_CONTRACT_DET_') INTO num1 ;
				EXIT WHEN num1 >= new.CONTRACT_DET_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_CONTRACT_DET_CONTRACT_DE_1
 before INSERT
  ON BILLADMIN.BIC_CONTRACT_DET
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_CONTRACT_DET_CONTRACT_DE_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_COST_BALANCE_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.BALANCE_KEY := old.BALANCE_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.BALANCE_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_COST_BALANCE_BAL_KEY_SEQ') INTO new.BALANCE_KEY ;
		IF new.BALANCE_KEY = 1 THEN 
			SELECT COALESCE(max(BALANCE_KEY),0) INTO v_newVal FROM billadmin.BIC_COST_BALANCE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_COST_BALANCE_BAL_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.BALANCE_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_COST_BALANCE_BAL_KEY_SEQ';
		IF num1 <= new.BALANCE_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_COST_BALANCE_BAL_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.BALANCE_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_COST_BALANCE_TRG
 before INSERT
  ON BILLADMIN.BIC_COST_BALANCE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_COST_BALANCE_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_COST_COST_NO_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.COST_NO := old.COST_NO; 
	ELSIF TG_OP = 'INSERT' AND new.COST_NO IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_COST_COST_NO_SEQ') INTO new.COST_NO ;
		IF new.COST_NO = 1 THEN 
			SELECT COALESCE(max(COST_NO),0) INTO v_newVal FROM billadmin.BIC_COST;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_COST_COST_NO_SEQ') INTO v_incval ;
				END LOOP;
				new.COST_NO := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_COST_COST_NO_SEQ';
		IF num1 <= new.COST_NO THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_COST_COST_NO_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.COST_NO;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_COST_COST_NO_TRG
 before INSERT
  ON BILLADMIN.BIC_COST
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_COST_COST_NO_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_COST_DIST_COST_DIST_KEY_TR_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.COST_DIST_KEY := old.COST_DIST_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.COST_DIST_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_COST_DIST_COST_DIST_KEY_SE') INTO new.COST_DIST_KEY ;
		IF new.COST_DIST_KEY = 1 THEN 
			SELECT COALESCE(max(COST_DIST_KEY),0) INTO v_newVal FROM billadmin.BIC_COST_DIST;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_COST_DIST_COST_DIST_KEY_SE') INTO v_incval ;
				END LOOP;
				new.COST_DIST_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_COST_DIST_COST_DIST_KEY_SE';
		IF num1 <= new.COST_DIST_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_COST_DIST_COST_DIST_KEY_SE') INTO num1 ;
				EXIT WHEN num1 >= new.COST_DIST_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_COST_DIST_COST_DIST_KEY_TR
 before INSERT
  ON BILLADMIN.BIC_COST_DIST
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_COST_DIST_COST_DIST_KEY_TR_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_EVENT_EVENT_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.EVENT_KEY := old.EVENT_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.EVENT_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_EVENT_EVENT_KEY_SEQ') INTO new.EVENT_KEY ;
		IF new.EVENT_KEY = 1 THEN 
			SELECT COALESCE(max(EVENT_KEY),0) INTO v_newVal FROM billadmin.BIC_EVENT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_EVENT_EVENT_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.EVENT_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_EVENT_EVENT_KEY_SEQ';
		IF num1 <= new.EVENT_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_EVENT_EVENT_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.EVENT_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_EVENT_EVENT_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_EVENT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_EVENT_EVENT_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_FILE_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_FILE_ROW_KEY_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_FILE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_FILE_ROW_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_FILE_ROW_KEY_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_FILE_ROW_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_FILE_TRG
 before INSERT
  ON BILLADMIN.BIC_FILE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_FILE_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_FILTER_FILTER_ID_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.FILTER_ID := old.FILTER_ID; 
	ELSIF TG_OP = 'INSERT' AND new.FILTER_ID IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_FILTER_FILTER_ID_SEQ') INTO new.FILTER_ID ;
		IF new.FILTER_ID = 1 THEN 
			SELECT COALESCE(max(FILTER_ID),0) INTO v_newVal FROM billadmin.BIC_FILTER;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_FILTER_FILTER_ID_SEQ') INTO v_incval ;
				END LOOP;
				new.FILTER_ID := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_FILTER_FILTER_ID_SEQ';
		IF num1 <= new.FILTER_ID THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_FILTER_FILTER_ID_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.FILTER_ID;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_FILTER_FILTER_ID_TRG
 before INSERT
  ON BILLADMIN.BIC_FILTER
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_FILTER_FILTER_ID_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_INVENTORY_INVENTORY_KEY_TR_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.INVENTORY_KEY := old.INVENTORY_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.INVENTORY_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_INVENTORY_INVENTORY_KEY_SE') INTO new.INVENTORY_KEY ;
		IF new.INVENTORY_KEY = 1 THEN 
			SELECT COALESCE(max(INVENTORY_KEY),0) INTO v_newVal FROM billadmin.BIC_INVENTORY;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_INVENTORY_INVENTORY_KEY_SE') INTO v_incval ;
				END LOOP;
				new.INVENTORY_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_INVENTORY_INVENTORY_KEY_SE';
		IF num1 <= new.INVENTORY_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_INVENTORY_INVENTORY_KEY_SE') INTO num1 ;
				EXIT WHEN num1 >= new.INVENTORY_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_INVENTORY_INVENTORY_KEY_TR
 before INSERT
  ON BILLADMIN.BIC_INVENTORY
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_INVENTORY_INVENTORY_KEY_TR_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_INVOICE_BATCH_BATCH_NO_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.BATCH_NO := old.BATCH_NO; 
	ELSIF TG_OP = 'INSERT' AND new.BATCH_NO IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_INVOICE_BATCH_BATCH_NO_SEQ') INTO new.BATCH_NO ;
		IF new.BATCH_NO = 1 THEN 
			SELECT COALESCE(max(BATCH_NO),0) INTO v_newVal FROM billadmin.BIC_INVOICE_BATCH;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_INVOICE_BATCH_BATCH_NO_SEQ') INTO v_incval ;
				END LOOP;
				new.BATCH_NO := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_INVOICE_BATCH_BATCH_NO_SEQ';
		IF num1 <= new.BATCH_NO THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_INVOICE_BATCH_BATCH_NO_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.BATCH_NO;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_INVOICE_BATCH_BATCH_NO_TRG
 before INSERT
  ON BILLADMIN.BIC_INVOICE_BATCH
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_INVOICE_BATCH_BATCH_NO_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_LOC_GRPKEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.LOC_GROUP_KEY := old.LOC_GROUP_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.LOC_GROUP_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_LOC_GRPKEY_SEQ') INTO new.LOC_GROUP_KEY ;
		IF new.LOC_GROUP_KEY = 1 THEN 
			SELECT COALESCE(max(LOC_GROUP_KEY),0) INTO v_newVal FROM billadmin.BIC_LOC_GRPKEY;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_LOC_GRPKEY_SEQ') INTO v_incval ;
				END LOOP;
				new.LOC_GROUP_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_LOC_GRPKEY_SEQ';
		IF num1 <= new.LOC_GROUP_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_LOC_GRPKEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.LOC_GROUP_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_LOC_GRPKEY_TRG
 before INSERT
  ON BILLADMIN.BIC_LOC_GRPKEY
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_LOC_GRPKEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_MARKDISC_MARKUP_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.MARKUP_KEY := old.MARKUP_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.MARKUP_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_MARKDISC_MARKUP_KEY_SEQ') INTO new.MARKUP_KEY ;
		IF new.MARKUP_KEY = 1 THEN 
			SELECT COALESCE(max(MARKUP_KEY),0) INTO v_newVal FROM billadmin.BIC_MARKDISC;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_MARKDISC_MARKUP_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.MARKUP_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_MARKDISC_MARKUP_KEY_SEQ';
		IF num1 <= new.MARKUP_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_MARKDISC_MARKUP_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.MARKUP_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_MARKDISC_MARKUP_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_MARKDISC
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_MARKDISC_MARKUP_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_MIN_MIN_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.MIN_KEY := old.MIN_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.MIN_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_MIN_MIN_KEY_SEQ') INTO new.MIN_KEY ;
		IF new.MIN_KEY = 1 THEN 
			SELECT COALESCE(max(MIN_KEY),0) INTO v_newVal FROM billadmin.BIC_MIN;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_MIN_MIN_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.MIN_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_MIN_MIN_KEY_SEQ';
		IF num1 <= new.MIN_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_MIN_MIN_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.MIN_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_MIN_MIN_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_MIN
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_MIN_MIN_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_ORDER_DETAIL_ORDER_DET_K_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ORDER_DET_KEY := old.ORDER_DET_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ORDER_DET_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_ORDER_DETAIL_ORDER_DET_KEY') INTO new.ORDER_DET_KEY ;
		IF new.ORDER_DET_KEY = 1 THEN 
			SELECT COALESCE(max(ORDER_DET_KEY),0) INTO v_newVal FROM billadmin.BIC_ORDER_DETAIL;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_ORDER_DETAIL_ORDER_DET_KEY') INTO v_incval ;
				END LOOP;
				new.ORDER_DET_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_ORDER_DETAIL_ORDER_DET_KEY';
		IF num1 <= new.ORDER_DET_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_ORDER_DETAIL_ORDER_DET_KEY') INTO num1 ;
				EXIT WHEN num1 >= new.ORDER_DET_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_ORDER_DETAIL_ORDER_DET_K_1
 before INSERT
  ON BILLADMIN.BIC_ORDER_DETAIL
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_ORDER_DETAIL_ORDER_DET_K_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_ORDER_HISTORY_ORDER_KEY_TR_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ORDER_KEY := old.ORDER_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ORDER_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_ORDER_HISTORY_ORDER_KEY_SE') INTO new.ORDER_KEY ;
		IF new.ORDER_KEY = 1 THEN 
			SELECT COALESCE(max(ORDER_KEY),0) INTO v_newVal FROM billadmin.BIC_ORDER_HISTORY;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_ORDER_HISTORY_ORDER_KEY_SE') INTO v_incval ;
				END LOOP;
				new.ORDER_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_ORDER_HISTORY_ORDER_KEY_SE';
		IF num1 <= new.ORDER_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_ORDER_HISTORY_ORDER_KEY_SE') INTO num1 ;
				EXIT WHEN num1 >= new.ORDER_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_ORDER_HISTORY_ORDER_KEY_TR
 before INSERT
  ON BILLADMIN.BIC_ORDER_HISTORY
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_ORDER_HISTORY_ORDER_KEY_TR_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_PRINTER_SERIAL_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.SERIAL_KEY := old.SERIAL_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.SERIAL_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_PRINTER_SERIAL_KEY_SEQ') INTO new.SERIAL_KEY ;
		IF new.SERIAL_KEY = 1 THEN 
			SELECT COALESCE(max(SERIAL_KEY),0) INTO v_newVal FROM billadmin.BIC_PRINTER;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_PRINTER_SERIAL_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.SERIAL_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_PRINTER_SERIAL_KEY_SEQ';
		IF num1 <= new.SERIAL_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_PRINTER_SERIAL_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.SERIAL_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_PRINTER_SERIAL_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_PRINTER
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_PRINTER_SERIAL_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_QUERY_TEMP_SERIAL_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.SERIAL_KEY := old.SERIAL_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.SERIAL_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_QUERY_TEMP_SERIAL_KEY_SEQ') INTO new.SERIAL_KEY ;
		IF new.SERIAL_KEY = 1 THEN 
			SELECT COALESCE(max(SERIAL_KEY),0) INTO v_newVal FROM billadmin.BIC_QUERY_TEMP;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_QUERY_TEMP_SERIAL_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.SERIAL_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_QUERY_TEMP_SERIAL_KEY_SEQ';
		IF num1 <= new.SERIAL_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_QUERY_TEMP_SERIAL_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.SERIAL_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_QUERY_TEMP_SERIAL_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_QUERY_TEMP
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_QUERY_TEMP_SERIAL_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_RATE_RATE_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.RATE_KEY := old.RATE_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.RATE_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_RATE_RATE_KEY_SEQ') INTO new.RATE_KEY ;
		IF new.RATE_KEY = 1 THEN 
			SELECT COALESCE(max(RATE_KEY),0) INTO v_newVal FROM billadmin.BIC_RATE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_RATE_RATE_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.RATE_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_RATE_RATE_KEY_SEQ';
		IF num1 <= new.RATE_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_RATE_RATE_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.RATE_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_RATE_RATE_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_RATE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_RATE_RATE_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_REMIT_REMIT_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.REMIT_KEY := old.REMIT_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.REMIT_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_REMIT_REMIT_KEY_SEQ') INTO new.REMIT_KEY ;
		IF new.REMIT_KEY = 1 THEN 
			SELECT COALESCE(max(REMIT_KEY),0) INTO v_newVal FROM billadmin.BIC_REMIT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_REMIT_REMIT_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.REMIT_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_REMIT_REMIT_KEY_SEQ';
		IF num1 <= new.REMIT_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_REMIT_REMIT_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.REMIT_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_REMIT_REMIT_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_REMIT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_REMIT_REMIT_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_REPORT_REPORT_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.REPORT_KEY := old.REPORT_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.REPORT_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_REPORT_REPORT_KEY_SEQ') INTO new.REPORT_KEY ;
		IF new.REPORT_KEY = 1 THEN 
			SELECT COALESCE(max(REPORT_KEY),0) INTO v_newVal FROM billadmin.BIC_REPORT;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_REPORT_REPORT_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.REPORT_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_REPORT_REPORT_KEY_SEQ';
		IF num1 <= new.REPORT_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_REPORT_REPORT_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.REPORT_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_REPORT_REPORT_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_REPORT
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_REPORT_REPORT_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_RPTSEND_REPORT_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.REPORT_KEY := old.REPORT_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.REPORT_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_RPTSEND_REPORT_KEY_SEQ') INTO new.REPORT_KEY ;
		IF new.REPORT_KEY = 1 THEN 
			SELECT COALESCE(max(REPORT_KEY),0) INTO v_newVal FROM billadmin.BIC_RPTSEND;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_RPTSEND_REPORT_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.REPORT_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_RPTSEND_REPORT_KEY_SEQ';
		IF num1 <= new.REPORT_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_RPTSEND_REPORT_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.REPORT_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_RPTSEND_REPORT_KEY_TRG
 before INSERT
  ON BILLADMIN.BIC_RPTSEND
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_RPTSEND_REPORT_KEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_SQL_SQL_ID_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.SQL_ID := old.SQL_ID; 
	ELSIF TG_OP = 'INSERT' AND new.SQL_ID IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_SQL_SQL_ID') INTO new.SQL_ID ;
		IF new.SQL_ID = 1 THEN 
			SELECT COALESCE(max(SQL_ID),0) INTO v_newVal FROM billadmin.BIC_SQL;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_SQL_SQL_ID') INTO v_incval ;
				END LOOP;
				new.SQL_ID := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_SQL_SQL_ID';
		IF num1 <= new.SQL_ID THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_SQL_SQL_ID') INTO num1 ;
				EXIT WHEN num1 >= new.SQL_ID;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_SQL_SQL_ID_1
 before INSERT
  ON BILLADMIN.BIC_SQL
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_SQL_SQL_ID_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_SYSTEM_FIELD_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ROW_KEY := old.ROW_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ROW_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_SYSTEM_FIELD_ROW_SEQ') INTO new.ROW_KEY ;
		IF new.ROW_KEY = 1 THEN 
			SELECT COALESCE(max(ROW_KEY),0) INTO v_newVal FROM billadmin.BIC_SYSTEM_FIELD;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_SYSTEM_FIELD_ROW_SEQ') INTO v_incval ;
				END LOOP;
				new.ROW_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_SYSTEM_FIELD_ROW_SEQ';
		IF num1 <= new.ROW_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_SYSTEM_FIELD_ROW_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ROW_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_SYSTEM_FIELD_TRG
 before INSERT
  ON BILLADMIN.BIC_SYSTEM_FIELD
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_SYSTEM_FIELD_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_USERBILLGRPKEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
      num1 bigint :=0;
      v_newVal bigint := 0;
      v_incval bigint := 0;
BEGIN
      IF TG_OP = 'UPDATE' THEN
            new.USERBILLGRPKEY := old.USERBILLGRPKEY; 
      ELSIF TG_OP = 'INSERT' AND new.USERBILLGRPKEY IS NULL THEN
            SELECT NEXTVAL('BILLADMIN.BIC_USERBILLGRPKEY_SEQ') INTO new.USERBILLGRPKEY ;
            IF new.USERBILLGRPKEY = 1 THEN 
                  SELECT COALESCE(max(USERBILLGRPKEY),0) INTO v_newVal FROM billadmin.BIC_USER_BILLGRPS;
                  IF v_newVal > 0 THEN
                        v_newVal := v_newVal + 1;
                        LOOP
                              EXIT WHEN v_incval >= v_newVal;
                              SELECT NEXTVAL('BILLADMIN.BIC_USERBILLGRPKEY_SEQ') INTO v_incval ;
                        END LOOP;
                        new.USERBILLGRPKEY := v_newVal;
                  END IF;
            END IF;
      ELSIF TG_OP = 'INSERT' THEN
            SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_USERBILLGRPKEY_SEQ';
            IF num1 <= new.USERBILLGRPKEY THEN
                  LOOP
                        SELECT NEXTVAL('BILLADMIN.BIC_USERBILLGRPKEY_SEQ') INTO num1 ;
                        EXIT WHEN num1 >= new.USERBILLGRPKEY;
                  END LOOP;
            END IF;
      END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_USERBILLGRPKEY_TRG
 before INSERT
  ON BILLADMIN.BIC_USER_BILLGRPS
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_USERBILLGRPKEY_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_USER_BILLGRPS_USER_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.USERBILLGRPKEY := old.USERBILLGRPKEY; 
	ELSIF TG_OP = 'INSERT' AND new.USERBILLGRPKEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_USER_BILLGRPS_USER_') INTO new.USERBILLGRPKEY ;
		IF new.USERBILLGRPKEY = 1 THEN 
			SELECT COALESCE(max(USERBILLGRPKEY),0) INTO v_newVal FROM billadmin.BIC_USER_BILLGRPS;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_USER_BILLGRPS_USER_') INTO v_incval ;
				END LOOP;
				new.USERBILLGRPKEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_USER_BILLGRPS_USER_';
		IF num1 <= new.USERBILLGRPKEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_USER_BILLGRPS_USER_') INTO num1 ;
				EXIT WHEN num1 >= new.USERBILLGRPKEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_USER_BILLGRPS_USER_1
 before INSERT
  ON BILLADMIN.BIC_USER_BILLGRPS
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_USER_BILLGRPS_USER_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.BIC_USER_PROFILE_USER_PROFIL_1_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.USER_PROFILE_KEY := old.USER_PROFILE_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.USER_PROFILE_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.BIC_USER_PROFILE_USER_PROFILE_') INTO new.USER_PROFILE_KEY ;
		IF new.USER_PROFILE_KEY = 1 THEN 
			SELECT COALESCE(max(USER_PROFILE_KEY),0) INTO v_newVal FROM billadmin.BIC_USER_PROFILE;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.BIC_USER_PROFILE_USER_PROFILE_') INTO v_incval ;
				END LOOP;
				new.USER_PROFILE_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'BIC_USER_PROFILE_USER_PROFILE_';
		IF num1 <= new.USER_PROFILE_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.BIC_USER_PROFILE_USER_PROFILE_') INTO num1 ;
				EXIT WHEN num1 >= new.USER_PROFILE_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER BIC_USER_PROFILE_USER_PROFIL_1
 before INSERT
  ON BILLADMIN.BIC_USER_PROFILE
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.BIC_USER_PROFILE_USER_PROFIL_1_function();

CREATE OR REPLACE FUNCTION BILLADMIN.PM_SQL_SCHED_SQL_SCHED_ID_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.SQL_SCHED_ID := old.SQL_SCHED_ID; 
	ELSIF TG_OP = 'INSERT' AND new.SQL_SCHED_ID IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.PM_SQL_SCHED_SQL_SCHED_ID_SEQ') INTO new.SQL_SCHED_ID ;
		IF new.SQL_SCHED_ID = 1 THEN 
			SELECT COALESCE(max(SQL_SCHED_ID),0) INTO v_newVal FROM billadmin.PM_SQL_SCHED;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.PM_SQL_SCHED_SQL_SCHED_ID_SEQ') INTO v_incval ;
				END LOOP;
				new.SQL_SCHED_ID := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'PM_SQL_SCHED_SQL_SCHED_ID_SEQ';
		IF num1 <= new.SQL_SCHED_ID THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.PM_SQL_SCHED_SQL_SCHED_ID_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.SQL_SCHED_ID;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER PM_SQL_SCHED_SQL_SCHED_ID_TRG
 before INSERT
  ON BILLADMIN.PM_SQL_SCHED
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.PM_SQL_SCHED_SQL_SCHED_ID_TRG_function();

CREATE OR REPLACE FUNCTION BILLADMIN.SRC_SYNC_ITEM_ITEM_KEY_TRG_function() RETURNS TRIGGER AS $$
BEGIN
DECLARE 
	num1 bigint :=0;
	v_newVal bigint := 0;
	v_incval bigint := 0;
BEGIN
	IF TG_OP = 'UPDATE' THEN
		new.ITEM_KEY := old.ITEM_KEY; 
	ELSIF TG_OP = 'INSERT' AND new.ITEM_KEY IS NULL THEN
		SELECT NEXTVAL('BILLADMIN.SRC_SYNC_ITEM_ITEM_KEY_SEQ') INTO new.ITEM_KEY ;
		IF new.ITEM_KEY = 1 THEN 
			SELECT COALESCE(max(ITEM_KEY),0) INTO v_newVal FROM billadmin.SRC_SYNC_ITEM;
			IF v_newVal > 0 THEN
				v_newVal := v_newVal + 1;
				LOOP
					EXIT WHEN v_incval >= v_newVal;
					SELECT NEXTVAL('BILLADMIN.SRC_SYNC_ITEM_ITEM_KEY_SEQ') INTO v_incval ;
				END LOOP;
				new.ITEM_KEY := v_newVal;
			END IF;
		END IF;
	ELSIF TG_OP = 'INSERT' THEN
		SELECT last_value INTO num1 FROM pg_sequences WHERE SEQUENCENAME = 'SRC_SYNC_ITEM_ITEM_KEY_SEQ';
		IF num1 <= new.ITEM_KEY THEN
			LOOP
				SELECT NEXTVAL('BILLADMIN.SRC_SYNC_ITEM_ITEM_KEY_SEQ') INTO num1 ;
				EXIT WHEN num1 >= new.ITEM_KEY;
			END LOOP;
		END IF;
	END IF;
END;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER SRC_SYNC_ITEM_ITEM_KEY_TRG
 before INSERT
  ON BILLADMIN.SRC_SYNC_ITEM
  FOR EACH ROW
  EXECUTE FUNCTION  BILLADMIN.SRC_SYNC_ITEM_ITEM_KEY_TRG_function();


